$Title  TWN model
$ontext
总水网络优化设计模型：案例数据取自Grossmann，Smith等
权衡主要包括新鲜水费用，废水处理费用，管线费用和环境性能
TWN Problem采用P formulation(学者已证明是最佳的表达方式)， 忽略水处理单元水损失，忽略杂质变化对总水量的影响
#暂未考虑双出口的水处理单元(例如反渗透膜法水处理), 后续可以添加

----需要区分建模的几个关键建模选择和默认选项：
    是否允许新鲜水送往水处理单元（默认不允许）
    全局优化默认相对误差 1%
    是否考虑自循环(默认不允许)，
    是否允许单元间的直接和间接循环(允许)
    是否区分再生回用和再生循环(默认不区分)
    用水单元类型（固定流率，固定杂质负荷，或者都固定）
    是否考虑将固定杂质负荷用水单元的水流率也固定（默认不固定）
    是否考虑水管线的投资和操作费用（基于算例）
    
----模型是通用的，包括固定杂质负荷和固定流率的用水单元，以及水处理单元，
----简化为WUN问题：水处理单元空集，环境阱不设浓度上界
----简化为WTN问题：只考虑固定流率用水单元，并且设置进口水流率为0
总水网络一共包括12类约束(不包括硬边界约束)
算例1： Grossmann 2006 example 1, CCE, Global optimization for the synthesis of integrated water systems in chemical processes
       Best Obj=117.05 t/h(固定用水量，不允许自循环);  Obj=101.57t/h(不固定用水量，不允许自循环)
算例2： Grossmann 2006 example 2, CCE, 
       Best Obj=$381,751.35;(固定用水量，不允许自循环); Obj= 381751.34(不固定用水量，不允许自循环)
算例3： Grossmann 2006 example 3, CCE, 
       Best Obj=$874,057.37 (固定用水量，不允许自循环); Obj= 874057.37(不固定用水量，不允许自循环)
算例4： Grossmann 2006 example 4, CCE, 
        Best Obj= $1033810.95 (固定用水量，不允许自循环);  Obj= 1031887.73(不固定用水量，不允许自循环)      

算例5： Kim 2012 case 2, Chemical Engineering Journal, System analysis of total water systems for water minimization
       ----优化时暂不考虑管线约束问题   Best obj =1199935.06$(不固定用水量，不允许自循环) 100.46s

算例6： Kim 2012 case 1, Chemical Engineering Journal, System analysis of total water systems for water minimization
       ----优化时暂不考虑管线约束问题（经典算例） 5个用水单元，3个杂质，3个水处理单元 Best obj = 1,361.84 k$(不固定用水量，不允许自循环)， Baron不收敛
                                                                            文献结果为 Fan 1,371.37 Kim 1,418.98

算例7： Alva-Argáez et al. 2007,Int. J. Environment and Pollution, A conceptual decomposition of MINLP models for the design of water-using systems
       Best Obj= $581141.24, 不允许自循环，最小流率为5t/h
#全局最优目标值的可能并不唯一，这是为何求解析解做不到的原因
0628更新日志： 加入多起点局部优化寻找高质量可行解程序
0701更新日志： 加入了asm集合表示允许的连接，进一步精简了模型，加入了管线约束和费用公式
0702更新日志： 加入了额外的管线约束水流率上下界约束，发现可以显著改善收敛，算例7， 8线程2500s收敛，（进一步基于算术和洞察精简浓度边界？）
0703更新日志： 加入了仅考虑管线操作费用的NLP模型，Yobjfun=4激活
0705更新日志： 证明了模型的通用性(可以转化为WUN或者WTN问题)
0718更新日志： 加入新鲜水到处理单元的连接可能性（稀释水从而提高处理量，减少新鲜水用量的目的）
0720更新日志： 水处理量上界更新为跟是否考虑循环有关
0826更新日志： 同时考虑杂质流和水流率限制的fsm边界(暂不加入)
0827更新日志： #关于是否考虑自循环和系统是否包括循环结构的区别，Fl.UP跟是否考虑自循环无关，跟是否考虑系统循环有关
              #GO第1和第2，3步

$offtext
$eolcom #
#==============================================================================
Option solprint = on ;
Option sysout   = off ;
option MIP      = Gurobi;
option MIQCP    = Baron;
option NLP      = Conopt;#Conopt, Baron
option QCP      = Conopt;# Gurobi, Baron, Conopt
option MINLP    = Baron;# Gurobi, Baron, Conopt, Convert, Dicopt
option optcr    = 0.01;    # eps_{OPT TOL} = 1 * 10^-3
option reslim   = 36000;# 1 hour time limit
option decimals = 2;
option Threads  = 8;
option bratio = 1;#不使用初始点作为求解器的基
#==========================代码块==============================================
*$onEcho > TWN_models.gms
*========================Part 1: Abstract model ================================================
*Sets, Parameters, variablbes and equations declared on total set
*Problem Topology
Sets
    case 'case index'
    r_   'Fresh water sources' 
    u_   'Water using units'
    l_   'Treatment units' 
    j_   'discharge sinks'
    c_   'Components'
    s_   'Splitters'
    m_   'Mixers';
Sets
    r(r_)  'Instance of fresh water sources'  
    u(u_)  'Instance of water using units'
    l(l_)  'Instance of treatment units' 
    j(j_)  'Instance of discharge sinks(virtual)'
    uc(u_) 'Instance of water using units of UC type'
    uf(u_) 'Instance of water using units of UF type'
    c(c_)  'Instance of components'
    s(s_)  'Instance of splitters'
    sr(s_) 'Instance of splitters at the outlet of fresh water sources'
    sc(s_) 'Instance of splitters at the outlet of water using units of UC type'
    sf(s_) 'Instance of splitters at the outlet of water using units of UF type'
    sl(s_) 'Instance of Splitters at the outlet of treatment units'
    m(m_)  'Instance of mixers'
    mu(m_) 'Instance of mixers at the inlet of water using units'
    mc(m_) 'Instance of mixers at the inlet of water using units of UC type'
    mf(m_) 'Instance of mixers at the inlet of water using units of UF type'
    ml(m_) 'Instance of Mixers at the inlet of treatment units'
    mj(m_) 'Instance of mixers at the inlet of discharge sink j';   
Sets
    rout(r_,s_)    'Allowable connection between r and s'  
    uout(u_,s_)    'Allowable connection between u and s'  
    uin(m_,u_)     'Allowable connection between m and u'
    lout(l_,s_)    'Allowable connection between l and s'  
    lin(m_,l_)     'Allowable connection between m and l'
    jin(m_,j_)     'Allowable connection between m and j'
    ssm(s_,m_) 'Self-recycled stream(from the outlet of unit XX  to the inlet of unit XX)'
    asm(s_,m_)     'Allowable connection from s to m'
    
;
Alias (u,ua),(uc,uca),(uf,ufa),(l,la),(sc,sca),(sl,sla);
*==============================================================================
Scalar
    Kloop            'Ratio of flowrate of total flow of cyclic of any unit l/u to the sum of flowrate of total flow of FucU' /3/
    V_pipe           'Water flow velocity in the  pipeline (s,m), m/s' /1/ #参考自Smith 2007
    VC_pipe          'Capital Cost coefficient of pipeline (s,m) of the variable part, $/m3/y' /1.001/ #参考自Smith 2007-3603.4/3600---并经过单位换算---
    FC_pipe          'Capital Cost coefficient of pipeline (s,m) of the fixed part, $/y'/124.6/
    FpipeUp          'addtitional limitation of maximum allowable water flowrate of the pipe, t/h' /1E+4/#a big enough number
    FpipeLo          'addtitional limitation of minimum allowable water flowrate of the pipe, t/h' /5/#2-5 
;
Parameters
    #physical related parameters     
    Prc(r_,c_)       'Concentration of component c of r, 10^3 ppm'
    PucinU(u_,c_)    'Upper bound of concentration of component c at the inlet of u, 10^3 ppm'
    PucinL(u_,c_)    'lower bound of concentration of component c at the inlet of u, 10^3 ppm'
    PuccoutU(u_,c_)  'Upper bound of concentration of component c at the outlet of uc, 10^3 ppm'
    FucU(u_)         'Upper bound of flowrate of total flow of uc, t/h'
    FucL(u_)         'lower bound of flowrate of total flow of uc, t/h'
    Fucc_delta(u_,c_)'Transferred load of flowrate of component flow c of uc from process stream, kg/h'
    Fufin(u_)        'Flowrate of total flow at the inlet of uf, t/h'
    Fufout(u_)       'Flowrate of total flow at the outlet of uf, t/h'
    Pufcout(u_,c_)   'Concentration of component c at the outlet of uf, 10^3 ppm'
    Rlc(l_,c_)       'Removal ratio of component c of treatment unit l'
    PlcinU(l_,c_)    'Upper bound of concentration of component c at the inlet of treatment unit l, 10^3 ppm'
    PjcU(j_,c_)      'Upper bound of concentration of component c at the inlet of discharge sink j, 10^3 ppm'
    D_pipe(s_,m_)    'length of the pipeline (s,m), m'
    #Cost related parameters
    H                'total time of opertion of the plant in one year, hours'
    Af               'annualized factor for investment on the treatment units or pipeline' 
    Alpha(l_)        'cost function exponent'
    Cr(r_)           'freshwater cost of source r, $/t'
    OCl(l_)          'investment cost coefficient for treatment unit l'
    ICl(l_)          'operating cost coefficient for treatment unit l'

; 
Parameters #辅助参数声明(当前上定界模型解参数)
    Num_connections_USol 'Connection number of the solution ' /1E+5/ #默认值取1E+5
    Fsm_USol(s_,m_)    'Flowrate of total flow from splitter s to mixer m, t/h'
    Fl_USol(l_)        'Flowrate of total flow of treatment unit l, t/h, t/h'
    Plcin_USol(l_,c_)  'Concentration of component c at the inlet of l, ppm'
    Plcout_USol(l_,c_) 'Concentration of component c at the outlet of l, ppm'                                                
    Pjc_USol(j_,c_)    'Concentration of component c of discharge sink j, ppm'
    Puccin_USol        'ppm'
    Puccout_USol(u_,c_)'ppm'
    Fuc_USol(u_)       't/h'
    Fj_USol(j_)        't/h'
    Fru_USol(r_,u_)
    Fuu_USol(u_,u_)
    Ful_USol(u_,l_)
    Fuj_USol(u_,j_)
    Flu_USol(l_,u_)
    Fll_USol(l_,l_)
    Flj_USol(l_,j_) 
    YObjfun '选择模型的目标函数'
    Yucflowratefixed 'uc单元是否固定水流率'
    Yrecycled
    Yunitselfrecycled '用水或者水处理单元是否考虑自循环'
    Ypipe_include '模型是否考虑管线因素'
    Yrl     '是否考虑新鲜水源r到处理单元l的流股存在'
    Report(case,*)      'Report'
    Report_mul(*,*)
;  
*=======================================================================
Positive Variables
    fsm(s_,m_)       'Flowrate of total flow from splitter s to mixer m, t/h'
    fr(r_)           'Flowrate of total flow of fresh water source l, t/h'
    fl(l_)           'Flowrate of total flow of treatment l, t/h'
    puccout(u_,c_)   'Concentration of component c at the outlet of unit uc, 10^3 ppm'
    plcout(l_,c_)    'Concentration of component c at the outlet of treatment unit l, 10^3 ppm'
#Variables used only for RP model
    fl_alpha(l_)
    fsmc_uc(s_,m_,c_)   'Flowrate of component flow c from splitter sc to mixer m, kg/h'
    fsmc_l(s_,m_,c_)   'Flowrate of component flow c from splitter sc to mixer m, kg/h'
Binary variables
    ysm(s_,m_)       'equal to 1 if the connection (s,m) is exist'
;
Free Variable  objval;
Equations
    p0_objfun_tf
    p0_objfun_tac_without_pipe
    p0_objfun_tac_with_pipe
    p0_objfun_tac_with_pipe_operating
    p0_objfun_tac_without_pipe_RP
    p0_objfun_tac_with_pipe_RP
    p0_objfun_tac_with_pipe_operating_RP
    p1(r_)
    p2(m_,u_,s_)
    p3(m_,u_)
    p4(u_,s_)
    p5(m_,u_,s_,c_)
    p5_RP(m_,u_,s_,c_)
    p6(m_,u_)
    p7(m_,u_)
    p8(m_,u_,c_)
    p8_RP(m_,u_,c_)
    p9(m_,u_,c_)
    p9_RP(m_,u_,c_)
    p10(m_,l_,s_)
    p11(m_,l_)
    p12(m_,l_,s_,c_)
    p12_RP(m_,l_,s_,c_)
    p13(m_,l_,c_)
    p13_RP(m_,l_,c_)
    p14(m_,j_,c_)
    p14_RP(m_,j_,c_)
    p15(s_,m_)
    p16(s_,m_)
;
*======================== Models (declared on total set and defined on subset) ================================================
#objective function: sum of total flowrate of fresh water
    #总水量为目标函数
    p0_objfun_tf$(YObjfun = 1)..                          objval =e= sum(r, fr(r)) + sum(l, fl(l)); 
    #费用最优为目标函数                                                      
    p0_objfun_tac_without_pipe$(YObjfun = 2)..            objval =e= H*sum(r, Cr(r)*fr(r)) 
                                                                     +H*sum(l, OCl(l)*fl(l))
                                                                     +Af*sum(l, ICl(l)*(fl(l)+1E-5)**Alpha(l))
                                                                     ;
    p0_objfun_tac_without_pipe_RP$(YObjfun = 2)..         objval =e= H*sum(r, Cr(r)*fr(r)) 
                                                                     +H*sum(l, OCl(l)*fl(l))
                                                                     +Af*sum(l, ICl(l)*fl_alpha(l))
                                                                     ;
    #目标函数总年化费用包括管线费用
    p0_objfun_tac_with_pipe_operating$(YObjfun = 3)..    objval =e= H*sum(r, Cr(r)*fr(r)) 
                                                                    + H*sum(l, OCl(l)*fl(l))
                                                                    + Af*sum(l, ICl(l)*(fl(l)+1E-5)**Alpha(l))
                                                                    + Af*sum(asm(s,m), (VC_pipe/V_pipe*fsm(s,m)
                                                                                        )*D_pipe(s,m))          
                                                                    ;
    p0_objfun_tac_with_pipe_operating_RP$(YObjfun = 3)..    objval =e= H*sum(r, Cr(r)*fr(r)) 
                                                                    + H*sum(l, OCl(l)*fl(l))
                                                                    + Af*sum(l, ICl(l)*fl_alpha(l))
                                                                    + Af*sum(asm(s,m), (VC_pipe/V_pipe*fsm(s,m)
                                                                                        )*D_pipe(s,m))          
                                                                    ;
    p0_objfun_tac_with_pipe$(YObjfun = 4)..              objval =e= H*sum(r, Cr(r)*fr(r)) 
                                                                    + H*sum(l, OCl(l)*fl(l))
                                                                    + Af*sum(l, ICl(l)*(fl(l)+1E-5)**Alpha(l))
                                                                    + Af*sum(asm(s,m), (VC_pipe/V_pipe*fsm(s,m)
                                                                                       + FC_pipe*ysm(s,m))*D_pipe(s,m))          
                                                                     ;

    p0_objfun_tac_with_pipe_RP$(YObjfun = 4)..              objval =e= H*sum(r, Cr(r)*fr(r)) 
                                                                    + H*sum(l, OCl(l)*fl(l))
                                                                    + Af*sum(l, ICl(l)*fl_alpha(l))
                                                                    + Af*sum(asm(s,m), (VC_pipe/V_pipe*fsm(s,m)
                                                                                       + FC_pipe*ysm(s,m))*D_pipe(s,m))          
                                                                     ;                                                           
    #mass balance of total flow at r
    p1(r)..                                     fr(r) =e= sum((sr,m)$(rout(r,sr) and asm(sr,m)), fsm(sr,m)); 
    #mass balance of total flow at uc 
    p2(mc,uc,sc)$(uin(mc,uc) and uout(uc,sc))..
                                                sum(s$asm(s,mc), fsm(s,mc)) =e= sum(m$asm(sc,m), fsm(sc,m));
    #mass balance of total flow at the inlet of uf 
    p3(mf,uf)$uin(mf,uf)..                      sum(s$asm(s,mf), fsm(s,mf)) =e= Fufin(uf);
    #mass balance of total flow at the outlet of uf 
    p4(uf,sf)$uout(uf,sf)..                     Fufout(uf) =e= sum(m$asm(sf,m), fsm(sf,m));
    #---mass balance of component flow c at uc 
    p5(mc,uc,sc,c)$(uin(mc,uc) and uout(uc,sc))..
                                                sum((r,sr)$(rout(r,sr) and asm(sr,mc)), fsm(sr,mc)*Prc(r,c)) 
                                                + sum((uf,sf)$(uout(uf,sf) and asm(sf,mc)), fsm(sf,mc)*Pufcout(uf,c))
                                                + sum((uca,sca)$(uout(uca,sca) and asm(sca,mc)), fsm(sca,mc)*puccout(uca,c))
                                                + sum((l,sl)$(lout(l,sl) and asm(sl,mc)), fsm(sl,mc)*plcout(l,c))
                                                + Fucc_delta(uc,c)
                                                =e=
                                                puccout(uc,c)*sum(m$asm(sc,m), fsm(sc,m));
                                           

    #mass balance of component flow c at uc in RP                                         
    p5_RP(mc,uc,sc,c)$(uin(mc,uc) and uout(uc,sc))..
                                                sum((r,sr)$(rout(r,sr) and asm(sr,mc)), fsm(sr,mc)*Prc(r,c)) 
                                                + sum((uf,sf)$(uout(uf,sf) and asm(sf,mc)), fsm(sf,mc)*Pufcout(uf,c))
                                                + sum((uca,sca)$(uout(uca,sca) and asm(sca,mc)), fsmc_uc(sca,mc,c))
                                                + sum((l,sl)$(lout(l,sl) and asm(sl,mc)), fsmc_l(sl,mc,c))
                                                + Fucc_delta(uc,c)
                                                =e=
                                                sum(m$asm(sc,m), fsmc_uc(sc,m,c));
                                                

    #upper bound  of total flow at the inlet of uc 
    p6(mc,uc)$uin(mc,uc)..                      sum(s$asm(s,mc), fsm(s,mc)) =l= FucU(uc);
    #lower bound  of total flow at the inlet of uc 
    #p7(mc,uc)$uin(mc,uc)..                      sum(s$(not ssm(s,mc)), fsm(s,mc)) =g= smax(c, Fucc_delta(uc,c)/puccout.UP(uc,c));
    p7(mc,uc)$uin(mc,uc)..                     sum(s$asm(s,mc), fsm(s,mc)) =g= FucL(uc);
    #upper bound  of component flow c at the inlet of u
    p8(m,u,c)$uin(m,u)..
                                                sum((r,sr)$(rout(r,sr) and asm(sr,m)), fsm(sr,m)*Prc(r,c)) 
                                                + sum((uf,sf)$(uout(uf,sf) and asm(sf,m)), fsm(sf,m)*Pufcout(uf,c)) 
                                                + sum((uc,sc)$(uout(uc,sc) and asm(sc,m)), fsm(sc,m)*puccout(uc,c))
                                                + sum((l,sl)$(lout(l,sl) and asm(sl,m)), fsm(sl,m)*plcout(l,c))
                                                =l=
                                                PucinU(u,c)*sum(s$asm(s,m), fsm(s,m));
    #upper bound  of component flow c at the inlet of u in RP
    p8_RP(m,u,c)$uin(m,u)..
                                                sum((r,sr)$(rout(r,sr) and asm(sr,m)), fsm(sr,m)*Prc(r,c)) 
                                                + sum((uf,sf)$(uout(uf,sf) and asm(sf,m)), fsm(sf,m)*Pufcout(uf,c)) 
                                                + sum((uc,sc)$(uout(uc,sc) and asm(sc,m)), fsmc_uc(sc,m,c))
                                                + sum((l,sl)$(lout(l,sl) and asm(sl,m)), fsmc_l(sl,m,c))
                                                =l=
                                                PucinU(u,c)*sum(s$asm(s,m), fsm(s,m));                                                                                 
    #lower bound  of component flow c at the inlet of u
    p9(m,u,c)$uin(m,u)..
                                                sum((r,sr)$(rout(r,sr) and asm(sr,m)),   fsm(sr,m)*Prc(r,c)) 
                                                + sum((uf,sf)$(uout(uf,sf) and asm(sf,m)), fsm(sf,m)*Pufcout(uf,c)) 
                                                + sum((uc,sc)$(uout(uc,sc) and asm(sc,m)), fsm(sc,m)*puccout(uc,c))
                                                + sum((l,sl)$(lout(l,sl) and asm(sl,m)), fsm(sl,m)*plcout(l,c))
                                                =g=
                                                PucinL(u,c)*sum(s$asm(s,m), fsm(s,m));
    #lower bound  of component flow c at the inlet of u in RP
    p9_RP(m,u,c)$uin(m,u)..
                                                sum((r,sr)$(rout(r,sr) and asm(sr,m)),   fsm(sr,m)*Prc(r,c)) 
                                                + sum((uf,sf)$(uout(uf,sf) and asm(sf,m)), fsm(sf,m)*Pufcout(uf,c)) 
                                                + sum((uc,sc)$(uout(uc,sc) and asm(sc,m)), fsmc_uc(sc,m,c))
                                                + sum((l,sl)$(lout(l,sl) and asm(sl,m)), fsmc_l(sl,m,c))
                                                =g=
                                                PucinL(u,c)*sum(s$asm(s,m), fsm(s,m));                                   

    #mass balance of total flow at l 
    p10(ml,l,sl)$(lin(ml,l) and lout(l,sl)) ..  sum(s$asm(s,ml), fsm(s,ml)) =e= sum(m$asm(sl,m), fsm(sl,m));
 
    #explicit expression of total flow at l
    p11(ml,l)$(lin(ml,l)) ..                    sum(s$asm(s,ml), fsm(s,ml)) =e= fl(l);

    #mass balance of component flow c  at l
    p12(ml,l,sl,c)$(lout(l,sl) and lin(ml,l))..
                                                sum(m$asm(sl,m), fsm(sl,m))*plcout(l,c) =e= (1- Rlc(l,c))*
                                                ( sum((r,sr)$(rout(r,sr) and asm(sr,ml)), fsm(sr,ml)*Prc(r,c))
                                                  + sum((uf,sf)$(uout(uf,sf) and asm(sf,ml)), fsm(sf,ml)*Pufcout(uf,c))
                                                  + sum((uc,sc)$(uout(uc,sc) and asm(sc,ml)), fsm(sc,ml)*puccout(uc,c))
                                                  + sum((la,sla)$(lout(la,sla) and asm(sla,ml)), fsm(sla,ml)*plcout(la,c))
                                                );
    #mass balance of component flow c  at l in RP                                                
    p12_RP(ml,l,sl,c)$(lout(l,sl) and lin(ml,l))..
                                                sum(m$asm(sl,m), fsmc_l(sl,m,c)) =e= (1- Rlc(l,c))*
                                                ( sum((r,sr)$(rout(r,sr) and asm(sr,ml)), fsm(sr,ml)*Prc(r,c))
                                                  + sum((uf,sf)$(uout(uf,sf) and asm(sf,ml)), fsm(sf,ml)*Pufcout(uf,c))
                                                  + sum((uc,sc)$(uout(uc,sc) and asm(sc,ml)), fsmc_uc(sc,ml,c))
                                                  + sum((la,sla)$(lout(la,sla) and asm(sla,ml)), fsmc_l(sla,ml,c))
                                                );                                                

    #Concentration upper bound of component  c  at lin
    p13(ml,l,c)$lin(ml,l)..                     sum((r,sr)$(rout(r,sr) and asm(sr,ml)), fsm(sr,ml)*Prc(r,c))
                                                + sum((uf,sf)$(uout(uf,sf) and asm(sf,ml)), fsm(sf,ml)*Pufcout(uf,c))
                                                + sum((uc,sc)$(uout(uc,sc) and asm(sc,ml)), fsm(sc,ml)*puccout(uc,c))
                                                + sum((la,sla)$(lout(la,sla) and asm(sla,ml)), fsm(sla,ml)*plcout(la,c))
                                                =l=
                                                PlcinU(l,c)*sum(s$asm(s,ml), fsm(s,ml));

    #Concentration upper bound of component  c  at lin in RP 
    p13_RP(ml,l,c)$lin(ml,l)..                  sum((r,sr)$(rout(r,sr) and asm(sr,ml)), fsm(sr,ml)*Prc(r,c))
                                                + sum((uf,sf)$(uout(uf,sf) and asm(sf,ml)), fsm(sf,ml)*Pufcout(uf,c))
                                                + sum((uc,sc)$(uout(uc,sc) and asm(sc,ml)), fsmc_uc(sc,ml,c))
                                                + sum((la,sla)$(lout(la,sla) and asm(sla,ml)), fsmc_l(sla,ml,c))
                                                =l=
                                                PlcinU(l,c)*sum(s$asm(s,ml), fsm(s,ml));


    #Concentration upper bound of component  c  at mjin
    p14(mj,j,c)$jin(mj,j)..                     sum((uf,sf)$(uout(uf,sf) and asm(sf,mj)), fsm(sf,mj)*Pufcout(uf,c))
                                                + sum((uc,sc)$(uout(uc,sc) and asm(sc,mj)), fsm(sc,mj)*puccout(uc,c))
                                                + sum((l,sl)$(lout(l,sl) and asm(sl,mj)), fsm(sl,mj)*plcout(l,c))
                                                =l=
                                                PjcU(j,c)*sum(s$asm(s,mj), fsm(s,mj));
    #Concentration upper bound of component  c  at mjin in RP
    p14_RP(mj,j,c)$jin(mj,j)..                  sum((uf,sf)$(uout(uf,sf) and asm(sf,mj)), fsm(sf,mj)*Pufcout(uf,c))
                                                + sum((uc,sc)$(uout(uc,sc) and asm(sc,mj)), fsmc_uc(sc,mj,c))
                                                + sum((l,sl)$(lout(l,sl) and asm(sl,mj)), fsmc_l(sl,mj,c))
                                                =l=
                                                PjcU(j,c)*sum(s$asm(s,mj), fsm(s,mj)); 

    #logical constraint of fsm and ysm
    p15(s,m)$(asm(s,m) and Ypipe_include)..                        fsm(s,m) =l= min(FpipeUp, fsm.Up(s,m))*ysm(s,m);
    p16(s,m)$(asm(s,m) and Ypipe_include)..                        fsm(s,m) =g= max(FpipeLo, fsm.Lo(s,m))*ysm(s,m);

*======================== LP underestimator of FL**alpha terms =========
Equations
    fl_alpha_undetesti(l_)  
;
    fl_alpha_undetesti(l)..                                        fl_alpha(l) =g= ((fl.Up(l))**Alpha(l)-(fl.Lo(l))**Alpha(l))/(fl.Up(l)-fl.Lo(l))*(fl(l)-fl.Lo(l)) + (fl.Lo(l))**Alpha(l);
*======================== Mc envelopes for BL terms =========
Equations
    fsmc_uc_MC1(u_,s_,m_,c_)
    fsmc_uc_MC2(u_,s_,m_,c_)
    fsmc_uc_MC3(u_,s_,m_,c_)
    fsmc_uc_MC4(u_,s_,m_,c_)
    fsmc_l_MC1(l_,s_,m_,c_)
    fsmc_l_MC2(l_,s_,m_,c_)
    fsmc_l_MC3(l_,s_,m_,c_)
    fsmc_l_MC4(l_,s_,m_,c_)
;
    #fsmc_uc(s_,m_,c_)   'Flowrate of component flow c from splitter sc to mixer m, kg/h'
    fsmc_uc_MC1(uc,sc,m,c)$(uout(uc,sc) and asm(sc,m))..          fsmc_uc(sc,m,c) =g= puccout.Up(uc,c)*fsm(sc,m) + puccout(uc,c)*fsm.Up(sc,m) -
                                                                                  puccout.Up(uc,c)*fsm.Up(sc,m);
    fsmc_uc_MC2(uc,sc,m,c)$(uout(uc,sc) and asm(sc,m))..          fsmc_uc(sc,m,c) =g= puccout.Lo(uc,c)*fsm(sc,m) + puccout(uc,c)*fsm.Lo(sc,m) -
                                                                                  puccout.Lo(uc,c)*fsm.Lo(sc,m);
    fsmc_uc_MC3(uc,sc,m,c)$(uout(uc,sc) and asm(sc,m))..          fsmc_uc(sc,m,c) =l= puccout.Up(uc,c)*fsm(sc,m) + puccout(uc,c)*fsm.Lo(sc,m) -
                                                                                  puccout.Up(uc,c)*fsm.Lo(sc,m);
    fsmc_uc_MC4(uc,sc,m,c)$(uout(uc,sc) and asm(sc,m))..          fsmc_uc(sc,m,c) =l= puccout.Lo(uc,c)*fsm(sc,m) + puccout(uc,c)*fsm.Up(sc,m) -
                                                                                  puccout.Lo(uc,c)*fsm.Up(sc,m);   
    #fsmc_l(s_,m_,c_)   'Flowrate of component flow c from splitter sl to mixer m, kg/h'
    fsmc_l_MC1(l,sl,m,c)$(lout(l,sl) and asm(sl,m))..          fsmc_l(sl,m,c) =g= plcout.Up(l,c)*fsm(sl,m) + plcout(l,c)*fsm.Up(sl,m) -
                                                                                  plcout.Up(l,c)*fsm.Up(sl,m);
    fsmc_l_MC2(l,sl,m,c)$(lout(l,sl) and asm(sl,m))..          fsmc_l(sl,m,c) =g= plcout.Lo(l,c)*fsm(sl,m) + plcout(l,c)*fsm.Lo(sl,m) -
                                                                                  plcout.Lo(l,c)*fsm.Lo(sl,m);
    fsmc_l_MC3(l,sl,m,c)$(lout(l,sl) and asm(sl,m))..          fsmc_l(sl,m,c) =l= plcout.Up(l,c)*fsm(sl,m) + plcout(l,c)*fsm.Lo(sl,m) -
                                                                                  plcout.Up(l,c)*fsm.Lo(sl,m);
    fsmc_l_MC4(l,sl,m,c)$(lout(l,sl) and asm(sl,m))..          fsmc_l(sl,m,c) =l= plcout.Lo(l,c)*fsm(sl,m) + plcout(l,c)*fsm.Up(sl,m) -
                                                                                  plcout.Lo(l,c)*fsm.Up(sl,m);

#====================================PMR Model(nf4r_formula)=====================================
Set np 'PMR 分割区间数总集合' /1*1000/;
#---fsmc_uc-----
Set uc_c_np(u_,c_,np) '不同puccout对应的分割区间数';
Parameters PuccoutnUp_pmr(u_,c_,np) '子区间浓度上界', PuccoutnLo_pmr(u_,c_,np) '子区间浓度下界';
Positive variables fsmcn_uc_pmr_d(s_,m_,c_,np) '凸包重构后fsm(sl,m)对应于puccout(l,c,np)的分解变量, 一定要引入下标c, 因为不同杂质对应的np是也就是(c,np)是独立，激活的np是不相关的';
Binary Variables ypuccout_pmr(u_,c_,np) 'puccout是否落在浓度子区间 np 的二元变量';
Equations
    eqbipuccout_pmr1(u_,c_)                   
    eqpuccoutU_pmr2a(u_,c_)                     
    eqpuccoutL_pmr2b(u_,c_)                      
    eqsumt_uc_pmr3a(u_,s_,m_,c_)                         
    eqfsmcnU_uc_pmr3b(u_,s_,m_,c_,np)                  
    eqfsmcnL_uc_pmr3c(u_,s_,m_,c_,np)                     
    fsmc_uc_pmr4a(u_,s_,m_,c_)                             
    fsmc_uc_pmr4b(u_,s_,m_,c_)                         
    fsmc_uc_pmr4c(u_,s_,m_,c_)                                 
    fsmc_uc_pmr4d(u_,s_,m_,c_)
;

    eqbipuccout_pmr1(uc,c)..                        sum(np$uc_c_np(uc,c,np), ypuccout_pmr(uc,c,np)) =e= 1;
    eqpuccoutU_pmr2a(uc,c)..                        puccout(uc,c) =l= sum(np$uc_c_np(uc,c,np), PuccoutnUp_pmr(uc,c,np)*ypuccout_pmr(uc,c,np));
    eqpuccoutL_pmr2b(uc,c)..                        puccout(uc,c) =g= sum(np$uc_c_np(uc,c,np), PuccoutnLo_pmr(uc,c,np)*ypuccout_pmr(uc,c,np));  
    eqsumt_uc_pmr3a(uc,sc,m,c)$(uout(uc,sc) and asm(sc,m))..
                                                    sum(np$uc_c_np(uc,c,np), fsmcn_uc_pmr_d(sc,m,c,np)) =e= fsm(sc,m);        
    eqfsmcnU_uc_pmr3b(uc,sc,m,c,np)$(uout(uc,sc) and asm(sc,m) and uc_c_np(uc,c,np))..
                                                    fsmcn_uc_pmr_d(sc,m,c,np) =l= fsm.Up(sc,m)*ypuccout_pmr(uc,c,np);
    eqfsmcnL_uc_pmr3c(uc,sc,m,c,np)$(uout(uc,sc) and asm(sc,m) and uc_c_np(uc,c,np))..
                                                    fsmcn_uc_pmr_d(sc,m,c,np) =g= fsm.Lo(sc,m)*ypuccout_pmr(uc,c,np);
    fsmc_uc_pmr4a(uc,sc,m,c)$(uout(uc,sc) and asm(sc,m))..
                                                    fsmc_uc(sc,m,c) =g= sum(np$uc_c_np(uc,c,np), PuccoutnUp_pmr(uc,c,np)*fsmcn_uc_pmr_d(sc,m,c,np)) + fsm.Up(sc,m)*puccout(uc,c) - sum(np$uc_c_np(uc,c,np), puccoutnUp_pmr(uc,c,np)*fsm.Up(sc,m)*ypuccout_pmr(uc,c,np));                                 
    fsmc_uc_pmr4b(uc,sc,m,c)$(uout(uc,sc) and asm(sc,m))..
                                                    fsmc_uc(sc,m,c) =g= sum(np$uc_c_np(uc,c,np), PuccoutnLo_pmr(uc,c,np)*fsmcn_uc_pmr_d(sc,m,c,np)) + fsm.Lo(sc,m)*puccout(uc,c) - sum(np$uc_c_np(uc,c,np), puccoutnLo_pmr(uc,c,np)*fsm.Lo(sc,m)*ypuccout_pmr(uc,c,np));                                 
    fsmc_uc_pmr4c(uc,sc,m,c)$(uout(uc,sc) and asm(sc,m))..
                                                    fsmc_uc(sc,m,c) =l= sum(np$uc_c_np(uc,c,np), PuccoutnUp_pmr(uc,c,np)*fsmcn_uc_pmr_d(sc,m,c,np)) + fsm.Lo(sc,m)*puccout(uc,c) - sum(np$uc_c_np(uc,c,np), puccoutnUp_pmr(uc,c,np)*fsm.Lo(sc,m)*ypuccout_pmr(uc,c,np));                                 
    fsmc_uc_pmr4d(uc,sc,m,c)$(uout(uc,sc) and asm(sc,m))..
                                                    fsmc_uc(sc,m,c) =l= sum(np$uc_c_np(uc,c,np), PuccoutnLo_pmr(uc,c,np)*fsmcn_uc_pmr_d(sc,m,c,np)) + fsm.Up(sc,m)*puccout(uc,c) - sum(np$uc_c_np(uc,c,np), puccoutnLo_pmr(uc,c,np)*fsm.Up(sc,m)*ypuccout_pmr(uc,c,np));                                                                         

#---fsmc_l-----
Set l_c_np(l_,c_,np) '不同plcout对应的分割区间数';
Parameters PlcoutnUp_pmr(l_,c_,np) '子区间浓度上界', PlcoutnLo_pmr(l_,c_,np) '子区间浓度下界';
Positive variables fsmcn_l_pmr_d(s_,m_,c_,np) '凸包重构后fsm(sl,m)对应于plcout(l,c,np)的分解变量, 一定要引入下标c, 因为不同杂质对应的np是也就是(c,np)是独立，激活的np是不相关的';
Binary Variables yplcout_pmr(l_,c_,np) 'plcout是否落在浓度子区间 np 的二元变量';
Equations
    eqbiplcout_pmr1(l_,c_)                   
    eqplcoutU_pmr2a(l_,c_)                     
    eqplcoutL_pmr2b(l_,c_)                      
    eqsumt_l_pmr3a(l_,s_,m_,c_)                         
    eqfsmcnU_l_pmr3b(l_,s_,m_,c_,np)                  
    eqfsmcnL_l_pmr3c(l_,s_,m_,c_,np)                     
    fsmc_l_pmr4a(l_,s_,m_,c_)                             
    fsmc_l_pmr4b(l_,s_,m_,c_)                         
    fsmc_l_pmr4c(l_,s_,m_,c_)                                 
    fsmc_l_pmr4d(l_,s_,m_,c_)
;

    eqbiplcout_pmr1(l,c)..                          sum(np$l_c_np(l,c,np), yplcout_pmr(l,c,np)) =e= 1;
    eqplcoutU_pmr2a(l,c)..                          plcout(l,c) =l= sum(np$l_c_np(l,c,np), PlcoutnUp_pmr(l,c,np)*yplcout_pmr(l,c,np));
    eqplcoutL_pmr2b(l,c)..                          plcout(l,c) =g= sum(np$l_c_np(l,c,np), PlcoutnLo_pmr(l,c,np)*yplcout_pmr(l,c,np));  
    eqsumt_l_pmr3a(l,sl,m,c)$(lout(l,sl) and asm(sl,m))..
                                                    sum(np$l_c_np(l,c,np), fsmcn_l_pmr_d(sl,m,c,np)) =e= fsm(sl,m);        
    eqfsmcnU_l_pmr3b(l,sl,m,c,np)$(lout(l,sl) and asm(sl,m) and l_c_np(l,c,np))..
                                                    fsmcn_l_pmr_d(sl,m,c,np) =l= fsm.Up(sl,m)*yplcout_pmr(l,c,np);
    eqfsmcnL_l_pmr3c(l,sl,m,c,np)$(lout(l,sl) and asm(sl,m) and l_c_np(l,c,np))..
                                                    fsmcn_l_pmr_d(sl,m,c,np) =g= fsm.Lo(sl,m)*yplcout_pmr(l,c,np);
    fsmc_l_pmr4a(l,sl,m,c)$(lout(l,sl) and asm(sl,m))..
                                                    fsmc_l(sl,m,c) =g= sum(np$l_c_np(l,c,np), PlcoutnUp_pmr(l,c,np)*fsmcn_l_pmr_d(sl,m,c,np)) + fsm.Up(sl,m)*plcout(l,c) - sum(np$l_c_np(l,c,np), plcoutnUp_pmr(l,c,np)*fsm.Up(sl,m)*yplcout_pmr(l,c,np));                                 
    fsmc_l_pmr4b(l,sl,m,c)$(lout(l,sl) and asm(sl,m))..
                                                    fsmc_l(sl,m,c) =g= sum(np$l_c_np(l,c,np), PlcoutnLo_pmr(l,c,np)*fsmcn_l_pmr_d(sl,m,c,np)) + fsm.Lo(sl,m)*plcout(l,c) - sum(np$l_c_np(l,c,np), plcoutnLo_pmr(l,c,np)*fsm.Lo(sl,m)*yplcout_pmr(l,c,np));                                 
    fsmc_l_pmr4c(l,sl,m,c)$(lout(l,sl) and asm(sl,m))..
                                                    fsmc_l(sl,m,c) =l= sum(np$l_c_np(l,c,np), PlcoutnUp_pmr(l,c,np)*fsmcn_l_pmr_d(sl,m,c,np)) + fsm.Lo(sl,m)*plcout(l,c) - sum(np$l_c_np(l,c,np), plcoutnUp_pmr(l,c,np)*fsm.Lo(sl,m)*yplcout_pmr(l,c,np));                                 
    fsmc_l_pmr4d(l,sl,m,c)$(lout(l,sl) and asm(sl,m))..
                                                    fsmc_l(sl,m,c) =l= sum(np$l_c_np(l,c,np), PlcoutnLo_pmr(l,c,np)*fsmcn_l_pmr_d(sl,m,c,np)) + fsm.Up(sl,m)*plcout(l,c) - sum(np$l_c_np(l,c,np), plcoutnLo_pmr(l,c,np)*fsm.Up(sl,m)*yplcout_pmr(l,c,np));                                                                         


#====================================Piecewise underestimators of fl_alpha=====================================
Set l_np(l_,np) '不同fl对应的fl_alpha分割区间数';
Parameters
    FlnUp_pwu(l_,np) '子区间fl上界', FlnLo_pwu(l_,np)'子区间fl下界'
    Fl_Slope_pwu(l_,np), Fl_Intercept_pwu(l_,np)
;
Positive variables fln(l_,np) '凸包重构后fl(l)的分解变量';
Binary Variables yfln(l_,np) 'fl是否落在fl子区间 np 的二元变量';
Equations
    fl_alpha_undetesti1(l_)
    fl_alpha_undetesti2(l_)
    fl_alpha_undetesti3(l_,np)
    fl_alpha_undetesti4(l_,np)
    fl_alpha_undetesti5(l_)
;
    fl_alpha_undetesti1(l)..                       fl_alpha(l) =g= sum(np$l_np(l,np), Fl_Slope_pwu(l,np)*fln(l,np)+Fl_Intercept_pwu(l,np)*yfln(l,np));
    fl_alpha_undetesti2(l)..                       fl(l) =e= sum(np$l_np(l,np), fln(l,np));
    fl_alpha_undetesti3(l,np)$l_np(l,np)..         fln(l,np) =l= FlnUp_pwu(l,np)*yfln(l,np);
    fl_alpha_undetesti4(l,np)$l_np(l,np)..         fln(l,np) =g= FlnLo_pwu(l,np)*yfln(l,np);
    fl_alpha_undetesti5(l)..                       sum(np$l_np(l,np), yfln(l,np)) =e= 1;  

*$offecho                                                              
*$include TWN_models
Model TWN/
    p0_objfun_tf
    p0_objfun_tac_without_pipe
    p0_objfun_tac_with_pipe
    p1
    p2       
    p3
    p4
    p5
    p6
    p7
    p8
    p9
    p10
    p11
    p12
    p13
    p14
    p15
    p16
    /;
Model TWN_LP/
    p0_objfun_tf
    p0_objfun_tac_without_pipe_RP
    p0_objfun_tac_with_pipe_RP
    p1
    p2       
    p3
    p4
    p5_RP
    p6
    p7
    p8_RP
    p9_RP
    p10
    p11
    p12_RP
    p13_RP
    p14_RP
    p15
    p16
    /;
Model TWN_RP_P1/
    p0_objfun_tf
    p0_objfun_tac_without_pipe_RP
    p0_objfun_tac_with_pipe_RP
    p1
    p2       
    p3
    p4
    p5_RP
    p6
    p7
    p8_RP
    p9_RP
    p10
    p11
    p12_RP
    p13_RP
    p14_RP
    p15
    p16
    fl_alpha_undetesti
    fsmc_uc_MC1
    fsmc_uc_MC2
    fsmc_uc_MC3
    fsmc_uc_MC4
    fsmc_l_MC1
    fsmc_l_MC2
    fsmc_l_MC3
    fsmc_l_MC4
    /;
Model TWN_RP_PN/
    p0_objfun_tf
    p0_objfun_tac_without_pipe_RP
    p0_objfun_tac_with_pipe_RP
    p1
    p2       
    p3
    p4
    p5_RP
    p6
    p7
    p8_RP
    p9_RP
    p10
    p11
    p12_RP
    p13_RP
    p14_RP
    p15
    p16
    fl_alpha_undetesti
    
    eqbipuccout_pmr1                  
    eqpuccoutU_pmr2a                    
    eqpuccoutL_pmr2b                     
    eqsumt_uc_pmr3a                      
    eqfsmcnU_uc_pmr3b               
    eqfsmcnL_uc_pmr3c                   
    fsmc_uc_pmr4a                        
    fsmc_uc_pmr4b                       
    fsmc_uc_pmr4c                                
    fsmc_uc_pmr4d
    
    eqbiplcout_pmr1                
    eqplcoutU_pmr2a                  
    eqplcoutL_pmr2b                  
    eqsumt_l_pmr3a                        
    eqfsmcnU_l_pmr3b             
    eqfsmcnL_l_pmr3c                   
    fsmc_l_pmr4a                          
    fsmc_l_pmr4b                   
    fsmc_l_pmr4c                            
    fsmc_l_pmr4d
    
    fl_alpha_undetesti1
    fl_alpha_undetesti2
    fl_alpha_undetesti3
    fl_alpha_undetesti4
    fl_alpha_undetesti5
    /;
$onecho > Data_input.gms
* ==================================Part 2: Data import======================
*Sets
* This part includes set and data definition,also includes hard bounds of Variables
Sets
    case /Ex1*Ex36/
    r_   /1*10/  
    u_   /1*20/
    l_   /1*20/
    j_   /1/
    c_   /1*10/     
    s_   /1*50/      
    m_   /1*50/
;
*Problem Parameters of all cases

Table Prc_all(case,r_,c_)
                1       2       3       4       5       6
    Ex1.1       0       0
    Ex2.1       0       0
    Ex3.1       0       0
    Ex4.1       0       0       0
    Ex5.1       0       0       0
    Ex6.1       0       0       0
    Ex7.1       0       0       0
;

#               1       2       3       4       5       6 
Table PucinU_all(case,u_,c_)
                1       2       3       4       5       6   
    Ex1.1       0       0
    Ex1.2       50      50
    Ex2.1       0       0
    Ex2.2       50      50
    Ex2.3       50      50
    Ex3.1       0       0
    Ex3.2       50      50
    Ex3.3       50      50
    Ex3.4       50      50
    
    Ex4.1       0       0       0
    Ex4.2       50      50      50
    Ex4.3       50      50      50
    Ex4.4       50      50      50
    Ex4.5       25      25      25

    Ex5.1       0       0       0
    Ex5.2       50      40      15
    Ex5.3       60      60      40

    Ex6.1       0       0       0
    Ex6.2       20      300     45
    Ex6.3       120     20      200
    Ex6.4       0       0       0
    Ex6.5       50      400     60
    
    Ex7.1       0       0       0
    Ex7.2       20      300     45
    Ex7.3       120     20      200
    Ex7.4       0       0       0
    Ex7.5       50      400     60
#               1       2       3       4       5       6 
;

Table Fucc_delta_all(case,u_,c_) #kg/h
                1       2       3       4       5       6   
    Ex1.1       1       1.5
    Ex1.2       1       1
    Ex2.1       1       1.5
    Ex2.2       1       1
    Ex2.3       1       1
    Ex3.1       1       1.5
    Ex3.2       1       1
    Ex3.3       1       1
    Ex3.4       2       2
    
    Ex4.1       1       1.5     1
    Ex4.2       1       1       1
    Ex4.3       1       1       1
    Ex4.4       2       2       2
    Ex4.5       1       1       0

    Ex5.1       3       2.4     1.8  #注意单位换算
    Ex5.2       4       3       3.6
    Ex5.3       1.5     0.6     2

    Ex6.1       0.75    20      1.75  #注意单位换算
    Ex6.2       3.4     414.8   4.59
    Ex6.3       5.6     1.4     520.8
    Ex6.4       0.16    0.48    0.16
    Ex6.5       0.8     60.8    0.48

    Ex7.1       0.75    20      1.75  #注意单位换算
    Ex7.2       3.4     414.8   4.59
    Ex7.3       5.6     1.4     520.8
    Ex7.4       0.16    0.48    0.16
    Ex7.5       0.8     60.8    0.48
#               1       2       3       4       5       6 

Parameter PucinL_all(case,u_,c_), Pufcout_all(case,u_,c_);
    PucinL_all(case,u_,c_) = 0; Pufcout_all(case,u_,c_) = 0;

Table FucU_all(case,u_) 
                1     2      3      4      5      6      7      8      9      10         
    Ex1         40    50
    Ex2         40    50     60
    Ex3         40    50     60     70
    Ex4         40    50     60     70     80
    Ex5         30    40     20
    Ex6         50    34     56     8      8
    Ex7         50    34     56     8      8
#               1     2      3      4      5      6      7      8      9      10 
;   
Table Fufin_all(case,u_) 
                1     2      3      4      5      6      7      8      9      10    
    Ex1
;
#               1     2      3      4      5      6      7      8      9      10  
Table Fufout_all(case,u_) 
                1     2      3      4      5      6      7      8      9      10    
    Ex1                            
;
#               1     2      3      4      5      6      7      8      9      10  
Table PjcU_all(case,j_,c_)
            1    2    3      4      5      6    
    Ex1.1   10   10
    Ex2.1   10   10
    Ex3.1   10   10
    Ex4.1   10   10   10
    Ex5.1   30   20   15
    Ex6.1   20   5    100
    Ex7.1   20   5    100
;

Table Rlc_all(case,l_,c_)
            1      2      3      4      5      6
    Ex1.1   0.95   0
    Ex1.2   0      0.95
    Ex2.1   0.95   0
    Ex2.2   0.8    0.9
    Ex2.3   0      0.95
    Ex3.1   0.95   0
    Ex3.2   0      0.90
    Ex4.1   0.95   0      0
    Ex4.2   0      0      0.95
    Ex4.3   0      0.95   0
    Ex5.1   0.7    0.8    0.85
    Ex5.2   0.5    0.6    0.4
    Ex6.1   0      0.999  0
    Ex6.2   0.7    0.9    0.98
    Ex6.3   0.95   0      0.5
    Ex7.1   0      0.999  0
    Ex7.2   0.7    0.9    0.98
    Ex7.3   0.95   0      0.5
#           1      2      3      4      5      6
;   
Table PlcinU_all(case,l_,c_) #输入规定的进口杂质浓度
            1       2      3      4      5      6
    Ex1.1   1E+5    1E+5
    Ex1.2   1E+5    1E+5
    Ex2.1   1E+5    1E+5
    Ex2.2   1E+5    1E+5
    Ex2.3   1E+5    1E+5
    Ex3.1   1E+5    1E+5
    Ex3.2   1E+5    1E+5
    Ex3.3   1E+5    1E+5
    Ex4.1   1E+5    1E+5   1E+5
    Ex4.2   1E+5    1E+5   1E+5
    Ex4.3   1E+5    1E+5   1E+5
    Ex5.1   1E+5    1E+5   1E+5
    Ex5.2   1E+5    1E+5   1E+5
    Ex6.1   1E+6    1E+6   1E+6
    Ex6.2   1E+6    1E+6   1E+6
    Ex6.3   1E+6    1E+6   1E+6
    Ex7.1   1E+6    1E+6   1E+6
    Ex7.2   1E+6    1E+6   1E+6
    Ex7.3   1E+6    1E+6   1E+6
#           1       2      3      4      5      6
;

#----费用相关------
Parameter H_all(case);
    H_all('Ex2') = 8000;
    H_all('Ex3') = 8000;
    H_all('Ex4') = 8000;
    H_all('Ex5') = 8600;
    H_all('Ex6') = 8600;
    H_all('Ex7') = 8600;
Parameter Af_all(case);
    Af_all('Ex2') = 0.1;
    Af_all('Ex3') = 0.1;
    Af_all('Ex4') = 0.1;
    Af_all('Ex5') = 1/1.55;#10% ，3 year = 0.4021148 /,  Fan 1/1.55
    Af_all('Ex6') = 1/1.55;#，0.1
    Af_all('Ex7') = 0.1;
    
Table Cr_all(case,r_) '$/t'
          1     2      3      4      5      6      7      8      9      10    
    Ex2   1
    Ex3   1
    Ex4   1
    Ex5   1
    Ex6   1
    Ex7   0.2 
#         1     2      3      4      5      6      7      8      9      10
    
Table Alpha_all(case,l_)
            1      2      3      4      5      6
    Ex2     0.7    0.7    0.7
    Ex3     0.7    0.7
    Ex4     0.7    0.7    0.7
    Ex5     0.7    0.7
    Ex6     0.7    0.7    0.7
    Ex7     0.7    0.7    0.7
#           1      2      3      4      5      6
; 
Table OCl_all(case,l_)
            1      2      3      4      5      6
    Ex2     1      0.033  0.0067
    Ex3     1      0.0067
    Ex4     1      0.04   0.0067
    Ex5     1      0.0067
    Ex6     1      0.0067 0
    Ex7     1      0.0067 0
#           1      2      3      4      5      6
;
Table ICl_all(case,l_)
            1      2      3      4      5      6
    Ex2     16800  24000  12600
    Ex3     16800  12600
    Ex4     16800  9500   12600
    Ex5     16800  12600
    Ex6     16800  12600  4800
    Ex7     16800  12600  4800
#           1      2      3      4      5      6
;
Table D_pipe_all(case,s_,m_) 'distance from s to m, m'
            1      2      3      4      5      6      7      8      9
    Ex7.1   0      30     80     150    400    90     150    200    1200
    Ex7.2   30     0      60     100    165    100    150    150    1000
    Ex7.3   80     60     0      50     75     120    90     350    800
    Ex7.4   150    100    50     0      150    250    170    400    650
    Ex7.5   400    165    75     150    0      300    120    200    300
    Ex7.6   90     100    120    250    300    0      125    80     250
    Ex7.7   150    150    90     170    120    125    0      35     100
    Ex7.8   200    150    350    400    200    80     35     0      100
    Ex7.9   30     25     70     50     90     200    500    600    2000
#           1      2      3      4      5      6      7      8      9
;   
$offecho
$include Data_input

#YObjfun = 1-新鲜水用量+水处理量, 2-总年化费用不包括管线,  3-总年化费用仅包括管线运行费, 4-总年化费用包括管线,
*======================Step 0： 模型,数据和参数设置导入=====================
#TWN.optfile = 1;
*TWN.solprint = 2;
*TWN_RP_PN.solprint = 2;
*TWN_RP_PN_Abt.solprint = 2;
*TWN_RP_PN_Abt.optfile = 2;#2对应的是模型的Abt属性文件，如果两个模型都使用1，则可能会造成一个属性文件包括不同的属性，会冲突
Scalar
    YGOstep1 'implement step 1 in GO or not' /0/,#默认没必要用，除非要执行边界紧缩或者上下定界模型交互
    YGOstep2_3 'implement step 2&3 in GO or not' /0/
    YGOstep4 'implement step 4(abt) in GO or not'/0/
    Gap 'current gap' /+Inf/, Gap_tol 'Gap tolerance' /1E-3/
    Dynamic_factor 'added partitions adjust factor '/0.1/#越大每轮增加的分割变量越少，等于1相当于大于均值的, 目前看取中小规模取0.1是最佳的，大和特大规模问题则建议取1，其实影响并不大，都取1就好
    Gap_rp_tol  'rel_gap for RP'/0/#默认RP求到最优解 误差为0
    NitermulU 'round upper bound for multistart'/1/
;
#--- Data Setting for GO (Step 1)---
Set itermul 'multistart total rounds'/1*1000/;
Scalar Time_start_1,Time_start_2;
#多起点停止辅助集合和参数
Set sol_ /1*1000/;
Set sol(sol_); sol(sol_) = no;
Parameter
    Objvalcou(sol_) '第sol局部解对应的目标值'
    Freq(sol_)  '第sol局部解对应的出现次数'
    Ysol_add  '判断是否增加了频数'
;
    Objvalcou(sol_) = 0;
    Freq(sol_) = 0;  
Set itermul_b '冒泡排序迭代轮次索引'/1*1000/;
Scalar Aul '冒泡排序辅助参数';

#--- Data Setting for GO (Step 2 and 3)---
Sets
    itergo 'iteration index for GO rounds'/1*100/
    qp '分割点数总集合' /1*1001/
    l_c_qp(l_,c_,qp) '不同plcout对应的分割点数'
    uc_c_qp(u_,c_,qp) '不同puccout对应的分割点数'
    l_qp(l_,qp)      '不同fl对应的分割点数'
;
Alias(qp_a, qp),(itergo_a,itergo);
Scalar
    LB 'current lower bound' /-1E+10/, UB 'current upper bound' /+1E+10/,
    NitergoU 'round upper bound for GO'/50/ #Step 2
    Epsilon_LB 'a small numeric value to avoid numeric problem'/1E-8/
    Nd_dynamic 'added partitions per round'/1/
    Ub_solve_switch_gap '切换原问题Dicopt求解方式的gap阈值' /1E-2/# 1%
    Total_timeU '总求解时间上限,s' /36000/
;
Parameter
    Report_go(itergo, *)
    Npmr_l_U(l_,c_) 'PMR_l 分割区间数'
    Plcoutq_pmr(l_,c_,qp) 'PMR_l分割点浓度值'
    Fsmc_l_devi(s_,m_,c_) 'devation of fsmc_l in RP'
    Plcout_BLsum_devi(l_,c_) 'total devation of fsmc in RP about pclout'
    Plcout_BLsum_devi_Ave 'nonzero average of Pclout_BLsum_devi'
    Npmr_l_LSol(l_,c_) '下定界模型RPyplcout_pmr(l,c,np)解所在区间索引的值'
    Plcout_LSol(l_,c_) '下定界模型Plcout(l,c)解'
    
    Npmr_uc_U(u_,c_) 'PMR_uc 分割区间数'
    Puccoutq_pmr(u_,c_,qp) 'PMR_uc分割点浓度值'
    Fsmc_uc_devi(s_,m_,c_) 'devation of fsmc_uc in RP'
    Puccout_BLsum_devi(u_,c_) 'total devation of fsmc_uc in RP about pclout'
    Pucccout_BLsum_devi_Ave 'nonzero average of Pcucout_BLsum_devi'
    Npmr_uc_LSol(u_,c_) '下定界模型RPypuccout_pmr(uc,c,np)解所在区间索引的值'
    Puccout_LSol(u_,c_) '下定界模型Puccout(uc,c)解'

    Npwu_l_U(l_) 'PWU_l 分割区间数'
    Flq_pwu(l_,qp) 'PWU_l分割点浓度值'
    
;
#Parameters for bound update and tighting
Parameters
    Caseindex '案例索引'
;

loop(case$(ord(case)=7),
#loop(case$(ord(case)>0 and ord(case)<=card(case)),
    Caseindex = ord(case);
    display '=================================================',Caseindex;
    LB =-1E+10; UB =+1E+10; 
    #优化目标选择
    YObjfun$(ord(case)=1) = 1;
    YObjfun$(ord(case)>1 and ord(case)<7) = 2;
    YObjfun$(ord(case)=7) = 4;
    
    Yucflowratefixed$(ord(case)<5) = 1;
    Yucflowratefixed$(ord(case)>=5) = 0;
    
    Ypipe_include$(ord(case)=7) = 1;
    Ypipe_include$(ord(case)<7) = 0;
    
    Yrecycled = 1;#默认允许系统循环
    Yunitselfrecycled = 0;#默认不允许自循环
    Yrl = 0;#默认不允许frt
    
    # extract domains for current problem(optional)
    r(r_) =yes$((ord(r_) = 1) or (ord(r_) > 1 and sum(c_$Prc_all(case,r_,c_), 1)));#注意要合在一起写
    l(l_) = sum(c_$Rlc_all(case,l_,c_), 1);
    j(j_) = yes$((ord(j_) = 1) or (ord(j_) > 1 and sum(c_$PjcU_all(case,j_,c_), 1)));
    uc(u_) = FucU_all(case,u_);
    uf(u_) = Fufin_all(case,u_);
    u(u_) = uc(u_) + uc(u_);#基于总流率上界判断合理
    c(c_) = sum(u_$PucinU_all(case,u_,c_), 1);
    s(s_) = yes$(ord(s_) <= card(r) + card(u) + card(l)); 
    sc(s_) = yes$(s(s_) and ord(s_) <= card(uc));
    sf(s_) = yes$(s(s_) and ord(s_) > card(uc) and ord(s_) <= card(u));
    sl(s_) = yes$(s(s_) and ord(s_) > card(u) and ord(s_) <= card(u) + card(l));
    sr(s_) = yes$(s(s_) and ord(s_) > card(u) + card(l));
    m(m_) = yes$(ord(m_) <= card(u) + card(l) + card(j));
    mu(m_) = yes$(m(m_) and ord(m_) <= card(u));
    mc(m_) = yes$(m(m_) and ord(m_) <= card(uc));
    mf(m_) = yes$(m(m_) and ord(m_) > card(uc) and ord(m_) <= card(u));
    ml(m_) = yes$(m(m_) and ord(m_) > card(u) and ord(m_) <= card(u) + card(l));
    mj(m_) = yes$(m(m_) and ord(m_) > card(u) + card(l));
    #二维子集合指定映射关系
    uout(u_,s_) =  yes$(u(u_) and (ord(s_) = ord(u_)));
    lout(l_,s_) =  yes$(l(l_) and (ord(s_) = ord(l_) + card(u)));
    rout(r_,s_) =  yes$(r(r_) and (ord(s_) = ord(r_) + card(u) + card(l)));
    uin (m_,u_) =  yes$(u(u_) and (ord(m_) = ord(u_)));
    lin (m_,l_) =  yes$(l(l_) and (ord(m_) = ord(l_) + card(u)));
    jin (m_,j_) =  yes$(j(j_) and (ord(m_) = ord(j_) + card(u) + card(l)));
    #sm子集合
    ssm(s_,m_) = yes$((sc(s_) or sf(s_) or sl(s_)) and (mu(m_) + ml(m_)) and (ord(s_)=ord(m_)));#自循环的分支流股
    #允许连接的流股集合
    asm(s_,m_)$(1-Yunitselfrecycled and (1-Yrl)) = yes$(s(s_) and m(m_) and (not(sr(s_) and ml(m_))) and (not(sr(s_) and mj(m_)))
                                                        and (not ssm(s_,m_)) #不允许自循环, 不包括frt
                                                        );
    asm(s_,m_)$(Yunitselfrecycled and (1-Yrl)) = yes$(s(s_) and m(m_) and (not(sr(s_) and ml(m_))) and (not(sr(s_) and mj(m_))));  

    asm(s_,m_)$((1-Yunitselfrecycled) and Yrl) = yes$(s(s_) and m(m_) and (not(sr(s_) and mj(m_)))
                                                      and (not ssm(s_,m_)) #包括frt,不允许自循环
                                                     );
    asm(s_,m_)$(Yunitselfrecycled and Yrl) = yes$(s(s_) and m(m_) and (not(sr(s_) and mj(m_)))); #包括frt,允许自循环
       
    #
    display ssm, asm; 
    # extract data(输入的边界值)
    Prc(r,c) = Prc_all(case,r,c)*1E-3;#单位换算为10^3 ppm
    PucinU(u,c) = PucinU_all(case,u,c)*1E-3;
    PucinL(u,c) = PucinL_all(case,u,c)*1E-3;
    FucU(uc) = FucU_all(case,uc);
    Fucc_delta(uc,c) = Fucc_delta_all(case,uc,c);
    PuccoutU(uc,c) = Fucc_delta(uc,c)/FucU(uc) + PucinU(uc,c);
    #display PuccoutU; 
    Fufin(uf) = Fufin_all(case,uf);
    Fufout(uf) = Fufout_all(case,uf);
    Pufcout(uf,c) = Pufcout_all(case,uf,c)*1E-3;
    Rlc(l,c) = Rlc_all(case,l,c);  
    PlcinU(l,c) = PlcinU_all(case,l,c)*1E-3;
    PjcU(j,c) = PjcU_all(case,j,c)*1E-3;
    D_pipe(s,m) = D_pipe_all(case,s,m);
    #display r, u, l, j, uc, uf, c, s, sc, sf, sl, sr, m, mu, mc, mf, ml, mj, uout, lout, rout, uin, lin, jin, Loop_sm;
    #display Prc, PucinU, PuccoutU, FucU, Fucc_delta, Fufin, Fufout, Pufcout, Rlc;
    #display D_pipe; 
    #费用参数输入
    H = H_all(case);           
    Af = Af_all(case);            
    Alpha(l) = Alpha_all(case,l);       
    Cr(r)= Cr_all(case,r);           
    OCl(l) = OCl_all(case,l);          
    ICl(l) = ICl_all(case,l);
    #display H,Af,Alpha,Cr,OCl,ICl;
#============ hard bound(同时考虑输入和拓扑结构推导)============
    fsm.UP(sr,ml)$asm(sr,ml) = sum(uf, Fufout(uf)) + sum(uc, FucU(uc));
    fsm.UP(sr,mc)$asm(sr,mc) = sum(uc$uin(mc,uc), FucU(uc));
    fsm.UP(sr,mf)$asm(sr,mf) = sum(uf$uin(mf,uf), Fufin(uf));
    fsm.UP(sc,mc)$asm(sc,mc) = min(sum(uca$uout(uca,sc), FucU(uca)), sum(uc$uin(mc,uc), FucU(uc)));
    fsm.UP(sc,mf)$asm(sc,mf) = min(sum(uc$uout(uc,sc), FucU(uc)), sum(uf$uin(mf,uf), Fufin(uf)));
    fsm.UP(sc,ml)$asm(sc,ml) = sum(uc$uout(uc,sc), FucU(uc));
    fsm.UP(sc,mj)$asm(sc,mj) = sum(uc$uout(uc,sc), FucU(uc));
    fsm.UP(sf,mc)$asm(sf,mc) = min(sum(uf$uout(uf,sf), Fufout(uf)), sum(uc$uin(mc,uc), FucU(uc)));
    fsm.UP(sf,mf)$asm(sf,mf) = min(sum(ufa$uout(ufa,sf), Fufout(ufa)), sum(uf$uin(mf,uf), Fufin(uf)));
    fsm.UP(sf,ml)$asm(sf,ml) = sum(uf$uout(uf,sf), Fufout(uf));
    fsm.UP(sf,mj)$asm(sf,mj) = sum(uf$uout(uf,sf), Fufout(uf));    

    fsm.UP(sl,mj)$asm(sl,mj) = sum(uf, Fufout(uf)) + sum(uc, FucU(uc));
    fsm.UP(sl,ml)$asm(sl,ml) = sum(uf, Fufout(uf)) + sum(uc, FucU(uc)); 
    fsm.UP(sl,mc)$asm(sl,mc) = sum(uc$uin(mc,uc), FucU(uc));
    fsm.UP(sl,mf)$asm(sl,mf) = sum(uf$uin(mf,uf), Fufin(uf));
    fsm.UP(s_,m_)$(asm(s_,m_) and (ord(s_)=ord(m_)) and ( (sc(s_) and mc(m_)) or ( (sl(s_) and ml(m_))) or ( sf(s_) and mf(m_)) ) and Yunitselfrecycled ) = Kloop*(sum(uf, Fufout(uf)) + sum(uc, FucU(uc)));#循环流股水量限制
    fl.UP(l)$Yrecycled = Kloop*(sum(uf, Fufout(uf)) + sum(uc, FucU(uc)));#上界跟是否允许系统包括循环有关
    fl.UP(l)$(1-Yrecycled) = sum(uf, Fufout(uf)) + sum(uc, FucU(uc));#上界跟是否允许系统包括循环有关
    #
    display fsm.UP, fl.UP;
    PucinU(u,c) = PucinU(u,c);
    #PucinL(u,c) = 0;
    puccout.UP(uc,c) = PuccoutU(uc,c);
    puccout.LO(uc,c) = Fucc_delta(uc,c)/FucU(uc);#这个很关键，因为直接参与BL项
    #puccout.LO(uc,c) = 0; 
    PlcinU(l,c) = min(PlcinU(l,c), max(smax(uf, Pufcout(uf,c)), smax(uc, PuccoutU(uc,c))));
    plcout.UP(l,c) = (1 - Rlc(l,c))*PlcinU(l,c);
    #plcout.LO(l,c) = 0;
    FucL(uc)$Yucflowratefixed = FucU_all(case,uc);#固定用水单元uc水流率
    FucL(uc)$(1-Yucflowratefixed) = 0;#不固定用水单元uc水流率
    FucL(uc) = max(FucL(uc), smax(c, Fucc_delta(uc,c)/puccout.UP(uc,c)));
    #display fsm.UP, PucinU, PucinL, puccout.UP, puccout.LO;
    #display PlcinU, plcout.UP, plcout.LO, FucU, FucL;
    
    #针对算例7的打断循环结构操作(基于结果逐步打断)
*    fsm.UP('8','7') = 0;#l3-l2
*    fsm.UP('7','3') = 0; #l2-uc3   
*    fsm.UP('7','2') = 0; #l2-uc2
*    
*    fsm.UP('8','3') = 0; #l2-uc3   
*    fsm.UP('8','2') = 0; #l2-uc2
*    
*    fsm.UP('6','2') = 0; #l2-uc2
*    fsm.UP('6','2') = 0; #l2-uc2
*    
*    fsm.UP('3','2') = 0; #uc3-uc2   
#=============MC solve=========
#Solve TWN_MC using LP minimizing objval;
#Report(case,'Obj_MC') = TWN_MC.objVal;
#============UBsolve&renew===========
    

    #======================== Global optimization algorithm ================================
    #---------------------------------------------------------------------------------------
    #------------------------ GO-Step 1：multistart local optimization ---------------------
    #---------------------------------------------------------------------------------------
    Time_start_1 = timeExec;
    if(YGOstep1,
        loop(itermul$(ord(itermul)<=NitermulU),
            puccout.L(uc,c) = uniform(puccout.Lo(uc,c), puccout.Up(uc,c));
            plcout.L(l,c) = uniform(plcout.Lo(l,c), plcout.Up(l,c));
            fsm.L(s,m)$asm(s,m) = uniform(fsm.Lo(s,m), fsm.Up(s,m));
            fl.L(l) = uniform(fl.Lo(l), fl.Up(l));
            ysm.L(s,m)$(asm(s,m) and Ypipe_include) = uniform(0, 1);#dicopt首先解的是rMINLP问题
            #WTN.solprint = 2;
            solve TWN using MINLP minimizing objval     
            #Report_mul(itermul,'NLP_stat')= TWN.modelstat;
            #Report_mul(itermul,'Solving_Time') = TWN.ResUsd;
            if(TWN.modelstat = 1 or TWN.modelstat = 2 or TWN.modelstat = 7 or TWN.modelstat = 8,
                Report_mul(itermul,'Objval_local')= objval.L;
                #------------step 1.1:对局部解进行统计----
                Ysol_add = 0;
                loop(sol,
                    if(abs(objval.L - Objvalcou(sol))<1E-3,#如果没发现新解
                        Freq(sol) = Freq(sol) + 1;
                        Ysol_add = 1;
                    );
                );
                if(Ysol_add = 0, #如果发现新的局部解
                    sol(sol_)$(ord(sol_) = (card(sol)+1)) = yes;
                    Objvalcou(sol_)$(ord(sol_) = card(sol)) = objval.L;
                    Freq(sol_)$(ord(sol_) = card(sol)) = 1; 
                );
                #display sol, Objvalcou, Freq;
                
                #------------step 1.2：更新最优解--------- 
                if(objval.L < UB,#更新最优解
                    UB = objval.L; 
                    Fsm_USol(s,m) = fsm.L(s,m);   
                    Fl_USol(l) = sum((sl,m)$lout(l,sl), fsm.L(sl,m));
                    Plcout_USol(l,c)$(Fl_USol(l)>0) = plcout.L(l,c)*1E+3; #注意有的f变量优化结果为0,浓度值没意义可以按0算
                    Fuc_USol(uc) = sum((sc,m)$uout(uc,sc), fsm.L(sc,m));
                    Puccin_USol(uc,c)$(Fuc_USol(uc)>0) = (puccout.L(uc,c) - Fucc_delta(uc,c)/Fuc_USol(uc))*1E+3; 
                    Puccout_USol(uc,c)$(Fuc_USol(uc)>0) = puccout.L(uc,c)*1E+3; #注意有的f变量优化结果为0,浓度值没意义可以按0算
                    Fj_USol(j) = sum((uf,sf,mj)$(uout(uf,sf) and jin(mj,j)), fsm.L(sf,mj))
                               + sum((uc,sc,mj)$(uout(uc,sc) and jin(mj,j)), fsm.L(sc,mj))
                               + sum((l,sl,mj)$(lout(l,sl) and jin(mj,j)), fsm.L(sl,mj))
                               ;
                    Pjc_USol(j,c) = (sum((uf,sf,mj)$(uout(uf,sf) and jin(mj,j)), fsm.L(sf,mj)*Pufcout(uf,c))
                                  + sum((uc,sc,mj)$(uout(uc,sc) and jin(mj,j)), fsm.L(sc,mj)*puccout.L(uc,c))
                                  + sum((l,sl,mj)$(lout(l,sl) and jin(mj,j)), fsm.L(sl,mj)*plcout.L(l,c)))/Fj_USol(j)*1E+3;
                    Fru_USol(r,u) = sum((sr,mu)$(rout(r,sr) and uin(mu,u)), fsm.L(sr,mu)); 
                    Fuu_USol(u,ua) = sum((s,mu)$(uout(u,s) and uin(mu,ua)), fsm.L(s,mu)); 
                    Ful_USol(u,l) = sum((s,ml)$(uout(u,s) and lin(ml,l)), fsm.L(s,ml)); 
                    Fuj_USol(u,j) = sum((s,mj)$(uout(u,s) and jin(mj,j)), fsm.L(s,mj)); 
                    Flu_USol(l,u) = sum((sl,mu)$(lout(l,sl) and uin(mu,u)), fsm.L(sl,mu));
                    Fll_USol(l,la) = sum((sl,ml)$(lout(l,sl) and lin(ml,la)), fsm.L(sl,ml));
                    Flj_USol(l,j)= sum((sl,mj)$(lout(l,sl) and jin(mj,j)), fsm.L(sl,mj));   
                    
                );
            else
                Report_mul(itermul,'Objval_local')= +INF;     
            );
        );
        #------------step 1.3: 统计结果重新排序(冒泡）---------
        loop(itermul_b$(ord(itermul_b) <= (card(sol)-1)),#一共执行N-1轮迭代
            loop(sol_$(ord(sol_) <= (card(sol) - ord(itermul_b))),
                if(Objvalcou(sol_) > Objvalcou(sol_+1),#两两交换，从前到后执行,小的放前面,第itermul轮，执行N-itermul次
                    Aul = Objvalcou(sol_);
                    Objvalcou(sol_) = Objvalcou(sol_+1);
                    Objvalcou(sol_+1) = Aul;
                    Aul = Freq(sol_);
                    Freq(sol_) = Freq(sol_+1);
                    Freq(sol_+1) = Aul;
                );
            );
        );
        #display "======================================step 1: Result display =====================================";
        #display sol, Objvalcou, Freq;#这块得加个冒泡排序，而且发现个规律，越接近全局最优解的，出现的频数越高，证明了方法的有效性！！！就是该方法很大概率发现近最优解
        #display 'Current solutions:',UB, Fsm_USol, Fuc_USol, Puccin_USol, Puccout_USol, Fl_USol, Plcout_USol, Fj_USol, Pjc_USol, Fucc_delta;
        #display Fru_USol, Fuu_USol, Ful_USol, Fuj_USol, Flu_USol, Fll_USol, Flj_USol;
        #display puccout.UP,puccout.LO,Puccout_USol, plcout.UP, plcout.LO,Plcout_USol;
        Report(case,'Mul_timeuse') = timeExec-Time_start_1;
    );
    #如果找到可行解，也输出
    if(Gap > Gap_Tol and UB<+INF,
        #display '============================================================================================================================';
        display 'the feasible soution is found!';
        display 'Feasible solutions:',UB, Fsm_USol, Fuc_USol, Puccin_USol, Puccout_USol, Fl_USol, Plcout_USol, Fj_USol, Pjc_USol, Fucc_delta;
        display Fru_USol, Fuu_USol, Ful_USol, Fuj_USol, Flu_USol, Fll_USol, Flj_USol;
        #display puccout.UP,puccout.LO,Puccout_USol, plcout.UP, plcout.LO,Plcout_USol;
        #display '=============================================================================================================================';
        #display  Npmr_U;
        TWN.optfile = 0;#还原
        #putclose bbcontrol 'mipstopexpr resusd >= 10000000';#还原
        #WTN_RP_PN_Abt.optfile = 0;#还原
    );

    Time_start_2 = timeExec;
  
    #求解非分割RP
    #
    Solve TWN_RP_P1 using MIP minimizing objval;
    #---全均匀分割---
    Npmr_l_U(l,c) = 400;
    l_c_np(l,c,np) = yes$(ord(np) <= Npmr_l_U(l,c));
    l_c_qp(l,c,qp) = yes$(ord(qp) <= (Npmr_l_U(l,c)+1));
    Plcoutq_pmr(l,c,qp)$l_c_qp(l,c,qp) = plcout.Lo(l,c)+(plcout.Up(l,c)-plcout.LO(l,c))/Npmr_l_U(l,c)*(ord(qp) - 1);   
    PlcoutnUp_pmr(l,c,np)$l_c_np(l,c,np) = sum(qp$(ord(qp) = (ord(np) + 1)), Plcoutq_pmr(l,c,qp));
    PlcoutnLo_pmr(l,c,np)$l_c_np(l,c,np) = sum(qp$(ord(qp) = ord(np)), Plcoutq_pmr(l,c,qp));
    display l_c_np, PlcoutnUp_pmr, PlcoutnLo_pmr;
    Npmr_uc_U(uc,c) = 400;
    uc_c_np(uc,c,np) = yes$(ord(np) <= Npmr_uc_U(uc,c));
    uc_c_qp(uc,c,qp) = yes$(ord(qp) <= (Npmr_uc_U(uc,c)+1));
    Puccoutq_pmr(uc,c,qp)$uc_c_qp(uc,c,qp) = puccout.Lo(uc,c)+(puccout.Up(uc,c)-puccout.LO(uc,c))/Npmr_uc_U(uc,c)*(ord(qp) - 1);   
    PuccoutnUp_pmr(uc,c,np)$uc_c_np(uc,c,np) = sum(qp$(ord(qp) = (ord(np) + 1)), Puccoutq_pmr(uc,c,qp));
    PuccoutnLo_pmr(uc,c,np)$uc_c_np(uc,c,np) = sum(qp$(ord(qp) = ord(np)), Puccoutq_pmr(uc,c,qp));
    display uc_c_np, PuccoutnUp_pmr, PuccoutnLo_pmr;
    
    Npwu_l_U(l) = 400; 
    l_np(l,np) = yes$(ord(np) <= Npwu_l_U(l));
    l_qp(l,qp) = yes$(ord(qp) <= (Npwu_l_U(l)+1));
    Flq_pwu(l,qp)$l_qp(l,qp) = fl.Lo(l)+(fl.Up(l)-fl.Lo(l))/Npwu_l_U(l)*(ord(qp) - 1);   
    FlnUp_pwu(l,np)$l_np(l,np) = sum(qp$(ord(qp) = (ord(np) + 1)), Flq_pwu(l,qp));
    FlnLo_pwu(l,np)$l_np(l,np) = sum(qp$(ord(qp) = ord(np)), Flq_pwu(l,qp));
    Fl_Slope_pwu(l,np)$l_np(l,np) = (FlnUp_pwu(l,np)**Alpha(l)-FlnLo_pwu(l,np)**Alpha(l))/(FlnUp_pwu(l,np)-FlnLo_pwu(l,np)); 
    Fl_Intercept_pwu(l,np)$l_np(l,np) = FlnLo_pwu(l,np)**Alpha(l) - Fl_Slope_pwu(l,np)*FlnLo_pwu(l,np);
    display l_np, FlnUp_pwu, FlnLo_pwu, Fl_Slope_pwu, Fl_Intercept_pwu;  
    

    Solve TWN_RP_PN using MIP minimizing objval;


    #============Result log===========
    Report(case,'ObjVal') = UB;
    Report(case,'Total time') = timeExec-Time_start_1;
    Report(case,'Gap') = Gap;    
    Report(case,'NumEqu') = TWN.numEqu;
    Report(case,'NumVar') = TWN.numVar;
    Report(case,'NumDVar') = TWN.numDVar;
    Report(case,'Solving Time') = TWN.ResUsd;
    Report(case,'NumR') = card(r);
    Report(case,'NumU') = card(u);
    Report(case,'NumL') = card(l);
    Report(case,'NumUC') = card(uc);
    Report(case,'NumUF') = card(uf);
    Report(case,'NumC') = card(c);
    
    #清理参数和变量当前值和边界设定 避免影响下个算例的计算
    option
*        clear = sol
*        clear = Objvalcou
*        clear = Freq
        clear = fsm
        clear = puccout
        clear = plcout
        #clear = UB
        clear = Fsm_USol
        clear = Fl_USol
        clear = Plcout_USol
        clear = Fuc_USol
        clear = Puccin_USol
        clear = Puccout_USol
        clear = Fj_USol
        clear = Pjc_USol
        clear = Fru_USol
        clear = Fuu_USol
        clear = Ful_USol
        clear = Fuj_USol
        clear = Flu_USol
        clear = Fll_USol
        clear = Flj_USol
    ;
);
*======================Step 1: solving the case model===========
#
display Report_mul;
display Report;
**--------Export to Excel using GDX utilities---------
*execute_unload "0614TWN_Conopt.gdx" Report Objvalcou, Freq
*execute 'gdxxrw.exe 0614TWN_Conopt.gdx o=0614TWN_Conopt.xlsx Par=Report   rng=ReportSheet!'
*execute 'gdxxrw.exe 0614TWN_Conopt.gdx o=0614TWN_Conopt.xlsx Par=Objvalcou   rng=ReportSheet2!'
*execute 'gdxxrw.exe 0614TWN_Conopt.gdx o=0614TWN_Conopt.xlsx Par=Freq   rng=ReportSheet3!'
